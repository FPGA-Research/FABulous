"""Utilities for emitting I/O pin ordering configuration files."""

from dataclasses import dataclass, field
from pathlib import Path
from typing import Self

import yaml

from FABulous.fabric_definition.define import PinSortMode, Side
from FABulous.fabric_definition.Fabric import Fabric
from FABulous.fabric_definition.SuperTile import SuperTile
from FABulous.fabric_definition.Tile import Tile


@dataclass
class PinOrderConfig:
    """Container describing pin ordering constraints for a segment."""

    min_distance: int | None = None
    max_distance: int | None = None
    pins: list[str] = field(default_factory=list)
    sort_mode: PinSortMode = PinSortMode.BUS_MAJOR
    reverse_result: bool = False

    def __call__(self, pins: list[str]) -> Self:
        """Bind a concrete pin list to this configuration instance."""
        self.pins = pins
        return self

    def to_dict(self) -> dict:
        """Return a serialisable dictionary representation."""
        pins = list(getattr(self, "pins", []) or [])
        return {
            "min_distance": self.min_distance,
            "max_distance": self.max_distance,
            "pins": pins,
            "sort_mode": str(self.sort_mode),
            "reverse_result": self.reverse_result,
        }


def _serialize_tile_ports(
    tile: Tile, prefix: str = "", external_port_side: Side = Side.SOUTH
) -> dict[str, list[dict]]:
    # Use string keys for sides (Side.name) so YAML emits plain string keys
    port_dict = {
        Side.NORTH.name: [],
        Side.EAST.name: [],
        Side.SOUTH.name: [],
        Side.WEST.name: [],
    }

    for port in tile.getNorthSidePorts():
        if regex := port.getPortRegex(indexed=True, prefix=prefix):
            port_dict[Side.NORTH.name].append(
                tile.pinOrderConfig[Side.NORTH]([regex]).to_dict()
            )
    port_dict[Side.NORTH.name].append(PinOrderConfig()([f"{prefix}UserCLKo"]).to_dict())
    port_dict[Side.NORTH.name].append(
        PinOrderConfig()([rf"{prefix}FrameStrobe_O\[\d+\]"]).to_dict()
    )

    for port in tile.getEastSidePorts():
        if regex := port.getPortRegex(indexed=True, prefix=prefix):
            port_dict[Side.EAST.name].append(
                tile.pinOrderConfig[Side.EAST]([regex]).to_dict()
            )
    port_dict[Side.EAST.name].append(
        PinOrderConfig()([rf"{prefix}FrameData_O\[\d+\]"]).to_dict()
    )

    for port in tile.getSouthSidePorts():
        if regex := port.getPortRegex(indexed=True, prefix=prefix):
            port_dict[Side.SOUTH.name].append(
                tile.pinOrderConfig[Side.SOUTH]([regex]).to_dict()
            )
    port_dict[Side.SOUTH.name].append(PinOrderConfig()([f"{prefix}UserCLK"]).to_dict())
    port_dict[Side.SOUTH.name].append(
        PinOrderConfig()([rf"{prefix}FrameStrobe\[\d+\]"]).to_dict()
    )

    for port in tile.getWestSidePorts():
        if regex := port.getPortRegex(indexed=True, prefix=prefix):
            port_dict[Side.WEST.name].append(
                tile.pinOrderConfig[Side.WEST]([regex]).to_dict()
            )
    port_dict[Side.WEST.name].append(
        PinOrderConfig()([rf"{prefix}FrameData\[\d+\]"]).to_dict()
    )

    # Place BEL external ports on the specified side (string key)
    for bel in tile.bels:
        pin_regexes = [
            f"{prefix}{name}" for name in bel.externalInput + bel.externalOutput
        ]
        if pin_regexes:
            port_dict[external_port_side.name].append(
                tile.pinOrderConfig[external_port_side](pin_regexes).to_dict()
            )

    return port_dict


def _serialize_supertile_ports(
    super_tile: SuperTile,
    prefix: str = "",
    external_port_sides: dict[tuple[int, int], Side] | None = None,
) -> dict[str, dict[str, list[dict]]]:
    """Serialize SuperTile ports, processing only the perimeter (external) sides.

    Parameters
    ----------
    super_tile : SuperTile
        The SuperTile to serialize
    prefix : str
        Prefix to add to port names
    external_port_sides : dict[tuple[int, int], Side] | None
        Mapping from tile coordinates (x, y) to the side where external BEL ports
        should be placed. If None or if a coordinate is not in the dict, defaults to
        using the perimeter side(s) of that tile.

    Returns
    -------
    dict[str, dict[str, list[dict]]]
        Dictionary mapping coordinate keys "X#Y#" to side configuration dictionaries
    """
    config_payload: dict[str, dict[str, list[dict]]] = {}
    ports_around = super_tile.getPortsAroundTile()

    for coord_key, port_lists in ports_around.items():
        if not port_lists:
            continue

        x, y = coord_key.split(",")
        tile_key = f"X{x}Y{y}"
        # Use string keys for sides here
        config_payload[tile_key] = {
            Side.NORTH.name: [],
            Side.EAST.name: [],
            Side.SOUTH.name: [],
            Side.WEST.name: [],
        }

        # Get the actual tile to access its pin order config and bels
        tile = super_tile.tileMap[int(y)][int(x)]
        if tile is None:
            continue

        tile_prefix = f"Tile_{tile_key}_{prefix}"
        perimeter_sides = set()
        for port_list in port_lists:
            if not port_list:
                continue

            # Determine which side this port list belongs to based on the first
            # port's sideOfTile
            side = port_list[0].sideOfTile
            perimeter_sides.add(side)

            # Process ports for this side (append to string-keyed dict)
            for port in port_list:
                if regex := port.getPortRegex(indexed=True, prefix=tile_prefix):
                    config_payload[tile_key][side.name].append(
                        tile.pinOrderConfig[side]([regex]).to_dict()
                    )

            # Add additional config pins based on side
            if side == Side.NORTH:
                config_payload[tile_key][side.name].append(
                    PinOrderConfig()([f"{tile_prefix}UserCLKo"]).to_dict()
                )
                config_payload[tile_key][side.name].append(
                    PinOrderConfig()([rf"{tile_prefix}FrameStrobe_O\[\d+\]"]).to_dict()
                )
            elif side == Side.EAST:
                config_payload[tile_key][side.name].append(
                    PinOrderConfig()([rf"{tile_prefix}FrameData_O\[\d+\]"]).to_dict()
                )
            elif side == Side.SOUTH:
                config_payload[tile_key][side.name].append(
                    PinOrderConfig()([f"{tile_prefix}UserCLK"]).to_dict()
                )
                config_payload[tile_key][side.name].append(
                    PinOrderConfig()([rf"{tile_prefix}FrameStrobe\[\d+\]"]).to_dict()
                )
            elif side == Side.WEST:
                config_payload[tile_key][side.name].append(
                    PinOrderConfig()([rf"{tile_prefix}FrameData\[\d+\]"]).to_dict()
                )

        # Add BEL external ports (only for tiles that have them)
        if tile.bels:
            for bel in tile.bels:
                pin_regexes = [
                    f"{prefix}{name}" for name in bel.externalInput + bel.externalOutput
                ]
                if pin_regexes:
                    # Determine which side to place external ports
                    if external_port_sides and (int(x), int(y)) in external_port_sides:
                        external_side = external_port_sides[(int(x), int(y))]
                    elif perimeter_sides:
                        # Default to first perimeter side if available
                        external_side = next(iter(perimeter_sides))
                    else:
                        # Fallback to SOUTH if no perimeter sides
                        external_side = Side.SOUTH

                    # append under string-keyed side
                    config_payload[tile_key][external_side.name].append(
                        tile.pinOrderConfig[external_side](pin_regexes).to_dict()
                    )

    return config_payload


def generate_IO_pin_order_config(
    fabric: Fabric,
    tile_or_super_tile: Tile | SuperTile,
    outfile: Path,
    prefix: str = "",
) -> None:
    """Generate I/O pin order configuration for a tile or super tile.

    The resulting YAML maps coordinate keys of the form ``X#Y#`` to side
    configuration dictionaries. Coordinates are enumerated from the top-left
    corner (``X0Y0``).

    Parameters
    ----------
    tile_or_super_tile : Tile | SuperTile
        The tile or super tile to generate configuration for
    outfile : Path
        Output YAML file path
    fabric : Fabric
        The fabric containing the tile or super tile
    prefix : str
        Prefix to add to port names
    """
    # Determine which side(s) to place external ports based on fabric position
    positions = fabric.find_tile_positions(tile_or_super_tile)

    if isinstance(tile_or_super_tile, SuperTile):
        # For SuperTiles, determine side for each internal tile coordinate
        external_port_sides: dict[tuple[int, int], Side] = {}
        if positions:
            # Use the position of the supertile's top-left tile
            # to determine base position
            base_x, base_y = positions[0] if len(positions) == 1 else (0, 0)

            for st_y, row in enumerate(tile_or_super_tile.tileMap):
                for st_x, st_tile in enumerate(row):
                    if st_tile is None:
                        continue
                    # Calculate fabric position of this tile within the supertile
                    fabric_x = base_x + st_x
                    fabric_y = base_y + st_y
                    border_side = fabric.determine_border_side(fabric_x, fabric_y)
                    if border_side:
                        external_port_sides[(st_x, st_y)] = border_side

        config_payload = _serialize_supertile_ports(
            tile_or_super_tile, prefix, external_port_sides
        )
    else:
        # For regular Tiles, determine a single side
        external_port_side = Side.SOUTH  # default
        if positions:
            x, y = positions[0]
            if border_side := fabric.determine_border_side(x, y):
                external_port_side = border_side

        config_payload = {
            "X0Y0": _serialize_tile_ports(
                tile_or_super_tile, prefix, external_port_side
            )
        }

    with outfile.open("w") as file_descriptor:
        yaml.dump(config_payload, file_descriptor)


def generate_fabric_IO_pin_order_config(
    fabric: Fabric,
    outfile: Path,
) -> None:
    """Generate fabric-level I/O pin order configuration.

    This generates a configuration file for placing IOs on the entire fabric,
    covering all perimeter tiles. The pins are arranged to align with the
    underlying tile IO positions.

    The resulting YAML maps fabric-level coordinate keys (X#Y#) to side
    configuration dictionaries, but only for perimeter tiles.

    Frame signals (FrameData and FrameStrobe) are partitioned across tiles:
    - FrameData: Each row has frameBitsPerRow bits (East/West sides)
    - FrameStrobe: Each column has maxFramesPerCol bits (North/South sides)

    Total fabric-level signals:
    - FrameData: frameBitsPerRow × numberOfRows bits
    - FrameStrobe: maxFramesPerCol × numberOfColumns bits

    Parameters
    ----------
    fabric : Fabric
        The fabric object containing the tile grid
    outfile : Path
        Output YAML file path for the fabric-level configuration
    """
    # Frame signal widths per tile
    # Each row has frameBitsPerRow bits of FrameData
    # Each column has maxFramesPerCol bits of FrameStrobe
    frame_data_per_row = fabric.frameBitsPerRow
    frame_strobe_per_col = fabric.maxFramesPerCol

    # Collect all pins for each fabric side (in order)
    north_pins: list[str] = []
    south_pins: list[str] = []
    east_pins: list[str] = []
    west_pins: list[str] = []

    # Iterate through all tiles and collect border pins
    for (x, y), tile in fabric:
        is_south = y == fabric.numberOfRows - 1
        is_west = x == 0

        # Calculate this position's own frame signals
        frame_strobe_start = x * frame_strobe_per_col
        frame_strobe_end = frame_strobe_start + frame_strobe_per_col - 1
        frame_data_start = y * frame_data_per_row
        frame_data_end = frame_data_start + frame_data_per_row - 1

        strobe_bits = set(range(frame_strobe_start, frame_strobe_end + 1))
        data_bits = set(range(frame_data_start, frame_data_end + 1))

        # If this is an empty border tile, add signals to adjacent tile
        if tile is None and (is_south or is_west):
            # Empty tile on north/south border: add FrameStrobe to east neighbor
            if is_south and y - 1 > 0:
                neighbor_key = (x, y - 1)
                if neighbor_key not in tile_frame_signals:
                    tile_frame_signals[neighbor_key] = {s: set() for s in Side}
                tile_frame_signals[neighbor_key][Side.SOUTH].update(strobe_bits)
            # Empty tile on west/east border: add FrameData to adjacent tile
            # West border: add to east neighbor's west side
            # East border: add to south neighbor's east side
            if is_west and x + 1 < fabric.numberOfColumns:
                neighbor_key = (x + 1, y)
                if neighbor_key not in tile_frame_signals:
                    tile_frame_signals[neighbor_key] = {s: set() for s in Side}
                tile_frame_signals[neighbor_key][Side.WEST].update(data_bits)
        else:
            # Non-empty tile: initialize with own signals
            if (x, y) not in tile_frame_signals:
                tile_frame_signals[(x, y)] = {s: set() for s in Side}
            if is_south:
                tile_frame_signals[(x, y)][Side.SOUTH].update(strobe_bits)
            if is_west:
                tile_frame_signals[(x, y)][Side.WEST].update(data_bits)

    # Second pass: process non-empty tiles and generate config
    for (x, y), tile in fabric:
        if tile is None:
            continue

        # Determine which sides are on the fabric perimeter
        is_north = y == 0
        is_south = y == fabric.numberOfRows - 1
        is_west = x == 0
        is_east = x == fabric.numberOfColumns - 1

        # Skip tiles that are not on the perimeter
        if not (is_north or is_south or is_west or is_east):
            continue

        tile_key = f"X{x}Y{y}"
        prefix = f"Tile_{tile_key}_"

        # Check if this tile is part of a supertile
        is_supertile_anchor = False
        supertile_obj = None
        for supertile in fabric.superTileDic.values():
            # Find the anchor tile (bottom-left in physical coordinates)
            anchor = supertile.tileMap[-1][0]
            if tile.name == anchor.name:
                # Check if this position is actually the supertile anchor
                positions = fabric.find_tile_positions(supertile)
                if positions and (x, y) in positions:
                    is_supertile_anchor = True
                    supertile_obj = supertile
                    # Adjust prefix for supertile
                    prefix = f"Tile_{tile_key}_"
                    break

        # Initialize side configurations
        config_payload[tile_key] = {
            Side.NORTH.name: [],
            Side.EAST.name: [],
            Side.SOUTH.name: [],
            Side.WEST.name: [],
        }

        if is_supertile_anchor and supertile_obj:
            # Process as supertile - only export perimeter sides
            # Get the internal tile coordinates within the supertile
            st_height = len(supertile_obj.tileMap)
            st_width = len(supertile_obj.tileMap[0])

            for st_y in range(st_height):
                for st_x in range(st_width):
                    st_tile = supertile_obj.tileMap[st_y][st_x]
                    if st_tile is None:
                        continue

                    # Calculate fabric position
                    fabric_x = x + st_x
                    fabric_y = y + st_y

                    # Check if this internal tile is on a fabric perimeter
                    st_is_north = fabric_y == 0
                    st_is_south = fabric_y == fabric.numberOfRows - 1
                    st_is_west = fabric_x == 0
                    st_is_east = fabric_x == fabric.numberOfColumns - 1

                    st_tile_prefix = f"Tile_X{fabric_x}Y{fabric_y}_{prefix}"

                    # Calculate frame signal bit ranges for this internal tile
                    # FrameStrobe: each column has maxFramesPerCol bits
                    st_frame_strobe_start = fabric_x * frame_strobe_per_col
                    st_frame_strobe_end = (
                        st_frame_strobe_start + frame_strobe_per_col - 1
                    )
                    # FrameData: each row has frameBitsPerRow bits
                    st_frame_data_start = fabric_y * frame_data_per_row
                    st_frame_data_end = st_frame_data_start + frame_data_per_row - 1

                    # Process each perimeter side of this internal tile
                    if st_is_north:
                        for port in st_tile.getNorthSidePorts():
                            if regex := port.getPortRegex(
                                indexed=True, prefix=st_tile_prefix
                            ):
                                config_payload[tile_key][Side.NORTH.name].append(
                                    st_tile.pinOrderConfig[Side.NORTH](
                                        [regex]
                                    ).to_dict()
                                )
                    if st_is_south:
                        for port in st_tile.getSouthSidePorts():
                            if regex := port.getPortRegex(
                                indexed=True, prefix=st_tile_prefix
                            ):
                                config_payload[tile_key][Side.SOUTH.name].append(
                                    st_tile.pinOrderConfig[Side.SOUTH](
                                        [regex]
                                    ).to_dict()
                                )
                        # Add UserCLK and FrameStrobe for this internal tile
                        config_payload[tile_key][Side.SOUTH.name].append(
                            PinOrderConfig()([f"{st_tile_prefix}UserCLK"]).to_dict()
                        )
                        for bit in range(
                            st_frame_strobe_start, st_frame_strobe_end + 1
                        ):
                            config_payload[tile_key][Side.SOUTH.name].append(
                                PinOrderConfig()([f"FrameStrobe\\[{bit}\\]"]).to_dict()
                            )

                    if st_is_east:
                        for port in st_tile.getEastSidePorts():
                            if regex := port.getPortRegex(
                                indexed=True, prefix=st_tile_prefix
                            ):
                                config_payload[tile_key][Side.EAST.name].append(
                                    st_tile.pinOrderConfig[Side.EAST]([regex]).to_dict()
                                )

                    if st_is_west:
                        for port in st_tile.getWestSidePorts():
                            if regex := port.getPortRegex(
                                indexed=True, prefix=st_tile_prefix
                            ):
                                config_payload[tile_key][Side.WEST.name].append(
                                    st_tile.pinOrderConfig[Side.WEST]([regex]).to_dict()
                                )
                        # Add FrameData for this internal tile
                        for bit in range(st_frame_data_start, st_frame_data_end + 1):
                            config_payload[tile_key][Side.WEST.name].append(
                                PinOrderConfig()([f"FrameData\\[{bit}\\]"]).to_dict()
                            )
        else:
            # Check which sides have neighbors
            has_north_neighbor = y > 0 and fabric.tile[y - 1][x] is not None
            has_south_neighbor = (
                y < fabric.numberOfRows - 1 and fabric.tile[y + 1][x] is not None
            )
            has_west_neighbor = x > 0 and fabric.tile[y][x - 1] is not None
            has_east_neighbor = (
                x < fabric.numberOfColumns - 1 and fabric.tile[y][x + 1] is not None
            )

            # Process all sides, but skip if neighbor exists
            if not has_north_neighbor:
                for port in tile.getNorthSidePorts():
                    if regex := port.getPortRegex(indexed=True, prefix=prefix):
                        config_payload[tile_key][Side.NORTH.name].append(
                            tile.pinOrderConfig[Side.NORTH]([regex]).to_dict()
                        )

            if not has_south_neighbor:
                for port in tile.getSouthSidePorts():
                    if regex := port.getPortRegex(indexed=True, prefix=prefix):
                        config_payload[tile_key][Side.SOUTH.name].append(
                            tile.pinOrderConfig[Side.SOUTH]([regex]).to_dict()
                        )
                config_payload[tile_key][Side.SOUTH.name].append(
                    PinOrderConfig()(
                        [
                            f"FrameStrobe\\[{bit}\\]"
                            for bit in sorted(tile_frame_signals[(x, y)][Side.SOUTH])
                        ]
                    ).to_dict()
                )
            if not has_east_neighbor:
                for port in tile.getEastSidePorts():
                    if regex := port.getPortRegex(indexed=True, prefix=prefix):
                        config_payload[tile_key][Side.EAST.name].append(
                            tile.pinOrderConfig[Side.EAST]([regex]).to_dict()
                        )

            if not has_west_neighbor:
                for port in tile.getWestSidePorts():
                    if regex := port.getPortRegex(indexed=True, prefix=prefix):
                        config_payload[tile_key][Side.WEST.name].append(
                            tile.pinOrderConfig[Side.WEST]([regex]).to_dict()
                        )
                config_payload[tile_key][Side.WEST.name].append(
                    PinOrderConfig()(
                        [
                            f"FrameData\\[{bit}\\]"
                            for bit in sorted(tile_frame_signals[(x, y)][Side.WEST])
                        ]
                    ).to_dict()
                )

            # Place BEL external ports on the border side
            if tile.bels:
                border_side = fabric.determine_border_side(x, y)
                if border_side:
                    for bel in tile.bels:
                        pin_regexes = [
                            f"{prefix}{name}"
                            for name in bel.externalInput + bel.externalOutput
                        ]
                        if pin_regexes:
                            config_payload[tile_key][border_side.name].append(
                                tile.pinOrderConfig[border_side](pin_regexes).to_dict()
                            )
    # FIXME: hardcode global clock
    config_payload[f"X1Y{fabric.numberOfRows - 1}"][Side.SOUTH.name].append(
        PinOrderConfig()(["UserCLK"]).to_dict()
    )

    with outfile.open("w") as file_descriptor:
        yaml.dump(config_payload, file_descriptor)
